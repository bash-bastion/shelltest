#!/usr/bin/env sh

assert() {
	if "$@"; then :; else
		printf '%s\n' "Error: shtest: Execution of command '$*' failed with exitcode $?"
		return 1
	fi
}

__shtest_util_exec_fn() {
	unset REPLY; REPLY=
	__shtest_function_name="${1:-}"

	if PATH= command -v "$__shtest_function_name" >/dev/null 2>&1; then
		if __shtest_function_output="$("$__shtest_function_name" 2>&1)"; then
			__shtest_function_exitcode=$?
		else
			__shtest_function_exitcode=$?
		fi

		printf '%s\n' "$__shtest_function_output" | while IFS= read -r __shtest_line; do
			printf '# %s\n' "$__shtest_line"
		done; unset __shtest_line
	fi
	REPLY=$__shtest_function_exitcode

	unset __shtest_function_name __shtest_function_exitcode
}

__shtest_main() {
	for arg; do case "$arg" in
	-h|--help)
		printf '%s\n' "Usage:
   shtest [flags] [test-file] [test-dir]

Flags:
   -h, --help
      Show help menu"
		return
		;;
	esac done

	export SHTEST_DIR= SHTEST_FILE= SHTEST_FUNCTION= SHTEST_SHELL=

	# for SHTEST_DIR; do

	SHTEST_DIR="$1"; shift
	if [ -z "$SHTEST_DIR" ]; then
		printf '%s\n' "Error: shtest: No test directory passed"
		exit 1
	elif [ -f "$SHTEST_DIR" ]; then
		printf '%s\n' "Error: shtest: Expected a directory, not file '$SHTEST_DIR'"
		exit 1
	elif [ ! -d "$SHTEST_DIR" ]; then
		printf '%s\n' "Error: shtest: Cannot find directory at '$SHTEST_DIR'"
		exit 1
	fi

	if ! SHTEST_DIR="$(
		if ! CDPATH= cd -P "$SHTEST_DIR"; then
			exit 1
		fi
		if ! pwd; then
			exit 1
		fi
	)"; then
		printf '%s\n' "Error: shtest: Could not convert test directory to full path"
	fi

	for SHTEST_FILE in "$SHTEST_DIR"/*.sh; do
		__shtest_functions_length=0
		__shtest_functions=

		# Parse shell script, adding testing functions to the list
		while IFS= read -r test_function; do
			# Functions part of the test suite must have a name that starts with 'test_'
			case "$test_function" in
				'test_'*'() {'*) : ;;
				*) continue ;;
			esac

			# This works on the assumption that there are no whitespace characters before
			# the function identifier. Additionally, this strips comments after the function,
			# which prevents "ignoring comment lines" in cases where tests are like Bats
			test_function="${test_function%%"() {"*}"

			# Ignore comment lines
			case "$test_function" in
				*'#'*) continue ;;
				*) : ;;
			esac

			__shtest_functions_length=$((__shtest_functions_length+1))
			__shtest_functions="$__shtest_functions$test_function:"
		done < "$SHTEST_FILE"; unset test_function

		# Execute all testing functions in current file
		if ! . "$SHTEST_FILE"; then
			printf '%s\n' "Error: shtest: Failed to source file '$SHTEST_FILE'"
			exit 1
		fi

		printf '%d..%d\n' '1' "$__shtest_functions_length"

		__shtest_util_exec_fn 'setup_file'

		__shtest_function_i=1
		while [ -n "$__shtest_functions" ]; do
			SHTEST_FUNCTION="${__shtest_functions%%:*}"

			__shtest_util_exec_fn 'setup'

			__shtest_util_exec_fn "$SHTEST_FUNCTION"
			if [ $REPLY -eq 0 ]; then
				printf '%s\n' "ok $__shtest_function_i $SHTEST_FUNCTION"
			else
				printf '%s\n' "not ok $__shtest_function_i $SHTEST_FUNCTION"
			fi

			__shtest_util_exec_fn 'teardown'

			__shtest_function_i=$((__shtest_function_i=__shtest_function_i+1))
			__shtest_functions="${__shtest_functions#*:}"
		done
		unset __shtest_function_i

		__shtest_util_exec_fn 'teardown_file'
	done; unset SHTEST_FILE

	unset __shtest_functions_length __shtest_functions

	# done
}


LC_ALL=C SHTEST=yes __shtest_main "$@"
